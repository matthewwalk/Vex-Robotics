#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rBaseEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rArmEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  lArmEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  cubeSolonoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl11, lBaseEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           rightShoulder, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightArm1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftArm2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightArm2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftArm1,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftShoulder,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

#pragma platform(VEX)

// what came first the chicken or the egg?
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Manual Control Variables
int debug = 0;
int armTarget = 0;
int armAngle = 0;
int baseAngle = 0;
int turnAngle = 0;
long elapsedTime = 0;

#define red 1
#define blue -1

int side = blue;

bool skyriseAuton = false;

//============= SET SENSOR METHOD =============
void setSensors() {
	int rArmAngle = SensorValue(rArmEncoder);
	int lArmAngle = SensorValue(lArmEncoder);
	armAngle = (rArmAngle + lArmAngle)/2;

	int lBaseAngle = SensorValue(lBaseEncoder);
	int rBaseAngle = SensorValue(rBaseEncoder);
	baseAngle = (rBaseAngle + lBaseAngle)/2;

	turnAngle = (lBaseAngle - rBaseAngle)/2;
}


// Pre Autonomous
void resetSensors() {
	SensorValue(lArmEncoder) = 0;
	SensorValue(rArmEncoder) = 0;
	SensorValue(lBaseEncoder) = 0;
	SensorValue(rBaseEncoder) = 0;
}

void resetEncoders() {
	SensorValue(lBaseEncoder) = 0;
	SensorValue(rBaseEncoder) = 0;
}

void waitForButtonRelease() {
	while (nLCDButtons != 0)
		wait1Msec(5);
}

void pre_auton() {
	resetSensors();
	SensorType[in1] = sensorNone;
	wait1Msec(500);
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
/*#define BUTTON nLCDButtons
#define leftButton 1
#define rightButton 4
#define centreButton 2
#define SELECT_AUTON 0
#define RESET_SENSORS 1
#define VOLTAGE 2

	int menuWindow = SELECT_AUTON;
	bLCDBacklight = true;
	bool menuOpen = true;
	while (menuOpen) {
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDPos(0, 0);

		if (vexRT[Btn8R] || vexRT[Btn8L])
			menuOpen = false;

		if (BUTTON != 0) {
			if (BUTTON == leftButton) { // Left Button
				menuWindow--;
			}
			else if (BUTTON == rightButton) { // Right Button
				menuWindow++;
			}
			else if (BUTTON == centreButton) { // Centre Button
				if (menuWindow == SELECT_AUTON) { // if you're looking at the auton
					// Red Cube
					// Blue Cube
					// Red Skyrise
					// Blue Skyrise
					if (skyriseAuton) {
						if (side == red)
							side = blue;
						else {
							side = red;
							skyriseAuton = false;
						}
					}
					else {
						if (side == red)
							side = blue;
						else {
							side = red;
							skyriseAuton = true;
						}
					}
				}
				else if (menuWindow == RESET_SENSORS) { // if you're looking at the sensors
					resetSensors();
				}
				else
					menuOpen = false; // Close menu
			}
			waitForButtonRelease();
		}

		if (menuWindow > VOLTAGE)
			menuWindow = SELECT_AUTON;
		else if (menuWindow < SELECT_AUTON)
			menuWindow = VOLTAGE;

		if (menuWindow == SELECT_AUTON) {
			if (skyriseAuton) {
				if (side == red)
					displayLCDCenteredString(0, "Red Skyrises");
				else
					displayLCDCenteredString(0, "Blue Skyrises");
			}
			else {
				if (side == red)
					displayLCDCenteredString(0, "Red Cube");
				else
					displayLCDCenteredString(0, "Blue Cube");
			}

			displayLCDCenteredString(1, "<   CHANGE   >");
		}
		else if (menuWindow == RESET_SENSORS) {
			displayLCDString(0, 0, "L:");
			displayNextLCDNumber(SensorValue(lArmEncoder));
			displayNextLCDString(" R:");
			displayNextLCDNumber(SensorValue(rArmEncoder));
			displayLCDCenteredString(1, "<    RESET   >");
		}
		else if (menuWindow == VOLTAGE) {
			string mainBattery, backupBattery;
			displayLCDString(0, 0, "M:");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0, 'v');
			displayNextLCDString(mainBattery);
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'v');
			displayNextLCDString(" B:");
			displayNextLCDString(backupBattery);
			displayLCDCenteredString(1, "<   FINISH   >");
		}
		wait1Msec(100);
	}*/
}

// PID Control Method
int oldArmAngle = armAngle;
int armSpeed = 0;
int oldArmTilt = 0;
void pid(bool count) {
	setSensors();

	if (count) {
		clearLCDLine(1);
		string msg = "";
		sprintf(msg, "%d", time100(T4));
		msg += " seconds";
		//displayLCDCenteredString(0, "Albert");
		displayLCDCenteredString(1, msg);

		elapsedTime = time100(T4);
	}

	// this is a very pretty code 
	// Proportional & Derivative Controller

	if (time1(T1) >= 50) { // Once every 50ms
		armSpeed = armAngle - oldArmAngle; // Determine rate of change in arm height
		oldArmAngle = armAngle;
		clearTimer(T1);
	}

	int armPower = (armTarget - armAngle)*1 - armSpeed; // positive when arm is too low
	int lPower = armPower;
	int rPower = armPower;

	//Correct arm if it is tilting
	// Arm leveling here

	if (armTarget == 0 && armAngle < 5) {
		motor[rightArm1]		= 0;
		motor[rightArm2]		= 0;
		motor[rightShoulder]	= 0;
		motor[leftArm1]			= 0;
		motor[leftArm2]			= 0;
		motor[leftShoulder]		= 0;
	}
	else {
		motor[rightArm1]		= rPower;
		motor[rightArm2]		= rPower;
		motor[rightShoulder]	= rPower;
		motor[leftArm1]			= lPower;
		motor[leftArm2]			= lPower;
		motor[leftShoulder]		= lPower;
	}
	wait1Msec(5);
}

// Autonomous Control Methods

void setMotors(int l, int r) {
	motor[LeftFront] = l;
	motor[LeftBack] = l;
	motor[RightBack] = r;
	motor[RightFront] = r;
}

void wait(int delay) {
	clearTimer(T2);
	while (time1(T2) < delay)
		pid(true);
}

// Arm control
void setArmHeight(int target) {
	armTarget = target;
}
void setArmHeightAndWait(int target) {
	setSensors();
	armTarget = target;
	// Wait until the arm is close to the target
	while (abs(armAngle - target) > 80)
		pid(true);
}

// Turn with target
void turnRight(int speed, int target) {
	setSensors();
	setMotors(speed*side, -speed*side);

	while (turnAngle*side < target)
		pid(true);

	setMotors(0, 0);
}
void turnLeft(int speed, int target) {
	setSensors();
	setMotors(-speed*side, speed*side);

	while (-turnAngle*side < target)
		pid(true);

	setMotors(0, 0);
}

// Linear motion with target
void driveForward(int speed, int target) {
	setSensors();
	setMotors(speed, speed);

	while (baseAngle < target)
		pid(true);

	setMotors(0, 0);
}
void driveBackward(int speed, int target) {
	setSensors();
	setMotors(-speed, -speed);

	while (baseAngle > target)
		pid(true);

	setMotors(0, 0);
}

// Button press for skills
//void waitForButton() {
//	while(SensorValue(touchSwitch))
//		pid(true);
//}

void hold() {
	while (true)
		pid(false);
}

int sign(int input) {
	if (input < 0)
		return -1;
	return 1;
}

void turnGyroTo(int target) {
	target *= side;
	while (abs(SensorValue(gyro) - target) > 5) {
		int power = (target - SensorValue(gyro));
		int minPower = 40*sign(power);
		float k = 0.05;
		setMotors(k*power+minPower, -(k*power+minPower));
		pid(true);
	}

	setMotors(0, 0);
}





task autonomous() {
	clearTimer(T1); // Timer used for PID control
	clearTimer(T4); // Global timer from start to end

	resetSensors();

	wait(500);

	setArmHeight(250);

	driveForward(70, 400);

	// Get first cube
	setArmHeightAndWait(-15);

	driveForward(70, 800);
	driveForward(40, 1030);

	setArmHeightAndWait(250);

	resetEncoders();

	// Turn to face 2nd cube
	turnGyroTo(1330);

	wait(100);

	resetEncoders();

	// Get second cube
	driveForward(127, 700);
	driveForward(50, 900);

	setArmHeight(-50);

	wait(1500);

	setArmHeightAndWait(580);

	wait(200);

	resetEncoders();

	driveForward(50, 320);

	wait(400);

	setArmHeightAndWait(465);

	wait(200);

	SensorValue(cubeSolonoid) = true;

	wait(1200);

	driveBackward(127, 0);

	wait(100);

	hold();


}// end of auton

int manualTurnSpeed = 0; // Used to make the robot turn on its own during manual control
int skyriseState = 0; // 1 indicates the robot is at the skyrise, 0 is at the autoloader.
int turnDelayTime = 0;


// Exponential Curve Functions
//int baseCurve(int joy) {
//	if (abs(joy) < 15) {
//		return 0;
//	}
//	else {
//		float curve = 1.05;
//		float slope = 97.0/(pow(curve, 112) - 1);
//		return (slope * (pow(curve, abs(joy)-15) - 1) + 30)* joy / abs(joy);
//	}
//}

int armPowerCalc(int input) {
	if (abs(input) < 50)
		return 0;
	if (input > 0)
		return 1.6494*(input - 50);
	return 1.6494*(input + 50);
}

// Start of User Control

task usercontrol() { // manual driver drive driving
	//resetSensors();
	setSensors();
	armTarget = 0;
	int oldArmAngle = armAngle;
	int armSpeed = 0;
	int armCounter = 0;
	int sixBarDifference = 0;
	armTarget = armAngle;
	while (true) {
		wait1Msec(10);

		// Sensor Setup ////////////////////
		setSensors();

		armCounter++;

		if (armCounter == 5) { // Once every 50ms
			armCounter = 0;
			armSpeed = armAngle - oldArmAngle; // Determine rate of change in arm height
			oldArmAngle = armAngle;
		}


		// BASE

		int lPower = armPowerCalc(vexRT[Ch3]) + armPowerCalc(vexRT[Ch1]);
		int rPower = armPowerCalc(vexRT[Ch3]) - armPowerCalc(vexRT[Ch1]);

		motor[LeftFront]  = lPower;
		motor[LeftBack]   = lPower;
		motor[RightFront] = rPower;
		motor[RightBack]  = rPower;

		// new shoulder

		// Arm preset heights
		if (vexRT[Btn8D])
			armTarget = 175;
		else if (vexRT[Btn8L])
			armTarget = 370;
		else if (vexRT[Btn8U])
			armTarget = 550;

		int armPower = 15;

		if (vexRT[Ch2] > 20) {
			armPower = (1.187*(vexRT[Ch2]-20));
			armTarget = armAngle + 2*armSpeed;
		}

		else if (vexRT[Ch2] < -20) {
			armPower = (1.187*(vexRT[Ch2]+20));
			armTarget = armAngle + 3*armSpeed;
		}

		else { // PD Control
			if (armAngle > 20 || armTarget > 20)
				armPower = 2*(armTarget - armAngle) - armSpeed; // positive when arm is too low //mult
		}

		int lSixPower = armPower;
		int rSixPower = armPower;

		if (armAngle > 100 || abs(vexRT[Ch2]) > 50) { // Don't do corrections if the arm is at the bottom of travel
			//Correct arm if it is tilting
			sixBarDifference = (SensorValue(rArmEncoder) - SensorValue(lArmEncoder)); // Positive if right is higher // mult
			lSixPower += sixBarDifference;
			rSixPower -= sixBarDifference;
		}


		motor[rightArm1]		= rSixPower;
		motor[rightArm2]		= rSixPower;
		motor[rightShoulder]	= rSixPower;

		motor[leftArm1]			= lSixPower;
		motor[leftArm2]			= lSixPower;
		motor[leftShoulder]		= lSixPower;


		//collector
		SensorValue(cubeSolonoid) = vexRT[Btn6U];
	}
}
// this is the end of the code
