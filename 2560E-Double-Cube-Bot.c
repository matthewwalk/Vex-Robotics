#pragma config(Sensor, dgtl1,  rBaseEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rArmEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  topCubeSolonoid, sensorDigitalOut)
#pragma config(Sensor, dgtl7,  lArmEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  botCubeSolonoid, sensorDigitalOut)
#pragma config(Sensor, dgtl11, lBaseEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           rightShoulder, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RightFront,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           rightArm1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           leftArm2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightArm2,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftArm1,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftBack,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LeftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          leftShoulder,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

/*
AUTON
SOLONOID CONTROL
HEIGHTS FOR POLLS
*/

#pragma platform(VEX)

//// PRE AUTON VARIABLES ////
bool MrunAutonomous = true;
string currentAutonomous = "none";

//// COMPETITION STUFF ////
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Manual Control Variables

//============= INTEGERS =============
int power = 0;
int frontLeft = 0, backLeft = 0, frontRight = 0, backRight = 0;

int armAngle = 0;
int baseAngle = 0;
int turnAngle = 0;

int armTarget = 0;
int baseTarget = 0;
int turnTarget = 0;

int lArmAngle = 0;
int rArmAngle = 0;

int lBaseAngle = 0;
int rBaseAngle = 0;

int armDiff = 0;

int armP = 0;
int armR = 0;
int armL = 0;

int baseP = 0;

int baseFL, baseFR, baseBL, baseBR;

int backwards = 1;

//============= BOOLEANS =============
bool turnLeft = false;
bool turnRight = false;

bool mRunAutonomous = true;
bool skyriseSide;


//============= DEFINE/SIDE =============
#define red 1
#define blue -1
int side = blue;

//============= SET SENSOR METHOD =============

void resetArm() {
	SensorValue(lArmEncoder) = 0;
	SensorValue(rArmEncoder) = 0;
}

void resetBase() {
	SensorValue(lBaseEncoder) = 0;
	SensorValue(rBaseEncoder) = 0;
}

//============= SET SENSOR METHOD =============
void setArm() {
	rArmAngle = SensorValue(rArmEncoder);
	lArmAngle = SensorValue(lArmEncoder);
	armAngle = (rArmAngle + lArmAngle)/2;
}

void setBase() {
	lBaseAngle = SensorValue(lBaseEncoder);
	rBaseAngle = SensorValue(rBaseEncoder);
	baseAngle = (rBaseAngle + lBaseAngle)/2;
}

void setTurn() {
	turnAngle = (lBaseAngle - rBaseAngle)/2;
}

// ============= LCD STUFF =============
void waitForButtonRelease() {
	while (nLCDButtons != 0) {
		wait1Msec(10);
	}
}
//STILL LCD STUFF
void waitForButtonPress() {
	while (nLCDButtons == 0) {
		wait1Msec(10);
	}
}

//============= PRE AUTON =============
void pre_auton() {
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	displayLCDPos(0,1);
	displayNextLCDString("Raven Robotics");
	displayLCDPos(1,6);
	displayNextLCDString("2560E | r.snake");

	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;
	int autonNum = 0;
	string autonCodes[4] = {
		"redCube",
		"redSkyrise",
		"blueSkyrise",
		"blueCube",
	};
	string autonNames[4] = {
		"Red Cube Zone",
		"Red Skyrise Zone",
		"Blue Skyrise Zone",
		"Blue Cube Zone",
	};

	currentAutonomous = autonCodes[0];
	displayLCDCenteredString(0, autonNames[0]);
	displayLCDCenteredString(1, "<-  Enter  ->");

	wait1Msec(1500);

	while (true) { //loop
		waitForButtonPress();
		if (nLCDButtons == centerButton) {//right button
			break;
		}
		else if (nLCDButtons == rightButton) {//right button
			autonNum++;
			if (autonNum > 3) {
				autonNum = 0;
			}
		}
		else if (nLCDButtons == leftButton) {//left button
			autonNum--;
			if (autonNum < 0) {
				autonNum = 3;
			}
		}
		else if (vexRT[Btn5U]) {
			break;
		}
		currentAutonomous = autonCodes[autonNum];
		displayLCDCenteredString(0, autonNames[autonNum]);
		waitForButtonRelease();
	}
	displayLCDCenteredString(1, "Selected");
	wait1Msec(1000);

	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "Raven Robotics");
	displayLCDCenteredString(1, "2560E r.snake");
}

//=========== METHODS FOR AUTON =============
void pdControl() {
	setArm();

	armP = 3*(armTarget - armAngle);
	armL = armP;
	armR = armP;

	armDiff = 2*(lArmAngle - rArmAngle);

	armR += armDiff;
	armL -= armDiff;

	motor[rightArm1] = armR;
	motor[rightArm2] = armR;
	motor[rightShoulder] = armR;
	motor[leftArm1] = armL;
	motor[leftArm2] = armL;
	motor[leftShoulder] = armL;

	wait1Msec(10);
}

void baseDrive() {
	setBase();

	baseP = 3*(baseTarget - baseAngle);

	baseFL = baseP; baseFR = baseP; baseBL = baseP; baseBR = baseP;

	int baseDiff = 2*(rBaseAngle - lBaseAngle);

	baseFR -= baseDiff; baseBR -= baseDiff;
	baseFL += baseDiff; baseBL += baseDiff;

	motor[LeftBack] = baseBL;
	motor[LeftFront] = baseFL;
	motor[RightFront] = baseFR;
	motor[RightBack] = baseBR;

	wait1Msec(10);
}

void turnLeftTo(int target) {
	SensorValue(lBaseEncoder) = 0;
	SensorValue(rBaseEncoder) = 0;
	turnTarget = target * side;
	while (abs(turnAngle - turnTarget) > 20) {
		int baseP = 3*(armTarget - armAngle);
		motor[RightBack] = -baseP;
		motor[RightFront] = -baseP;
		motor[LeftBack] =baseP;
		motor[LeftFront] = baseP;
		pdControl();
	}
}

void turnRightTo(int target) {
	SensorValue(lBaseEncoder) = 0;
	SensorValue(rBaseEncoder) = 0;
	turnTarget = target * side;
	while (abs(turnAngle - turnTarget) > 20) {
		int baseP = 3*(armTarget - armAngle);
		motor[RightBack] = baseP;
		motor[RightFront] = baseP;
		motor[LeftBack] = -baseP;
		motor[LeftFront] = -baseP;
		pdControl();
	}
}

void moveTo(int target) {
	resetBase();
	baseTarget = target;
	while (abs(baseAngle) < abs(baseTarget)) {
		baseDrive();
		pdControl();
	}
}

void pause(float time) {
	time1[T1] = 0;
	while (time1[T1] < time * 1000) {
		pdControl();
	}
}

void raiseArmTo (int target) {
	armTarget = target;
	while (armAngle + 15 < target) {
		pdControl();
	}
}

void dropCubes(float time) {
	time1[T1] = 0;
	while (time1[T1] < time * 1000) {
		SensorValue(botCubeSolonoid) = true;
		SensorValue(topCubeSolonoid) = true;
		pdControl();
	}
	SensorValue(botCubeSolonoid) = false;
	SensorValue(topCubeSolonoid) = true;
	wait1Msec(100);
	pdControl();
}


task autonomous() {
	resetArm();
	resetBase();
	turnRight = false;
	turnLeft = false;

	mRunAutonomous = true;

	if (strcmp(currentAutonomous, "redCube") == 0 || strcmp(currentAutonomous, "redSkyrise") == 0)  { //if it's the red side
		side = -1;
		if(strcmp(currentAutonomous, "redCube") == 0) {
			skyriseSide = false;
		}
		else {
			skyriseSide = true;
		}
	}

	else {
		side = 1;
		if(strcmp(currentAutonomous, "blueSkyrise") == 0) {
			skyriseSide = true;
		}
		else {
			skyriseSide = false;
		}
	}

	if (mRunAutonomous == true) {
		if (skyriseSide == false) {

			//test
			moveTo(450);



		//	raiseArmTo(175);

			pause(2);

			moveTo(-400);

		//	raiseArmTo(0);

			MrunAutonomous = false; // finish
		}
		else if (skyriseSide == true){

			MrunAutonomous = false;
		}// end of skyrise side

		else {

			MrunAutonomous = false;
		}// end of secret weapon
	} // end of mRUn
}// end of auton


task usercontrol() { // manual driver drive driving
	resetArm();
	resetBase();
	setArm();
	setBase();
	armTarget = 0;
	int oldArmAngle = armAngle;
	int armSpeed = 0;
	int armCounter = 0;
	int sixBarDifference = 0;
	while (true) {
		wait1Msec(10);

		// Sensor Setup ////////////////////
		setArm();
		setBase();

		armCounter++;

		if (armCounter == 5) { // Once every 50ms
			armCounter = 0;
			armSpeed = armAngle - oldArmAngle; // Determine rate of change in arm height
			oldArmAngle = armAngle;
		}


		// BASE

		if (abs(vexRT[Ch3]) > 50) {
			if (vexRT[Ch3] > 50)
				power = 1.649*(vexRT[Ch3]-50);
			else
				power = 1.649*(vexRT[Ch3]+50);

			frontLeft = power;
			backLeft = power;
			frontRight = power;
			backRight = power;
		}

		else if (abs(vexRT[Ch1]) > 50) { // try to turn
			if (vexRT[Ch1] > 50)
				power = 1.649*(vexRT[Ch1]-50);
			else
				power = 1.649*(vexRT[Ch1]+50);

			frontLeft = -power;
			backLeft = power;
			frontRight = power;
			backRight = -power;
		}
		else {
			power = 0;
			frontLeft = power;
			backLeft = power;
			frontRight = power;
			backRight = power;
		}

		motor[LeftFront]  = frontLeft;
		motor[RightFront] = frontRight;
		motor[LeftBack]   = backLeft;
		motor[RightBack]  = backRight;

		// new shoulder

		if (vexRT[Btn8D])
			armTarget = 175;

		else if (vexRT[Btn8L])
			armTarget = 370;

		else if (vexRT[Btn8U])
			armTarget = 550;

		int armPower = 15;

		if (vexRT[Ch2] > 20) {
			armPower = ((127/107)*(vexRT[Ch2]-20));
			armTarget = armAngle + 2*armSpeed;
		}

		else if (vexRT[Ch2] < -20) {
			armPower = ((127/107)*(vexRT[Ch2]+20))/2;
			armTarget = armAngle + 3*armSpeed;
		}

		else { // PD Control
			if (abs(armTarget - armAngle) > 30 || armTarget > 80)
				armPower = 2*(armTarget - armAngle) - armSpeed; // positive when arm is too low //mult
		}

		int lSixPower = armPower;
		int rSixPower = armPower;

		if (armAngle > 100 || abs(vexRT[Ch2]) > 50) { // Don't do corrections if the arm is at the bottom of travel
			//Correct arm if it is tilting
			sixBarDifference = (rArmAngle - lArmAngle); // Positive if right is higher // mult
			lSixPower += sixBarDifference;
			rSixPower -= sixBarDifference;
		}


		motor[rightArm1] = rSixPower;
		motor[rightArm2] = rSixPower;
		motor[rightShoulder] = rSixPower;

		motor[leftArm1] = lSixPower;
		motor[leftArm2] = lSixPower;
		motor[leftShoulder] = lSixPower;


		//collector
		SensorValue(botCubeSolonoid) = vexRT[Btn6U];
		SensorValue(topCubeSolonoid) = vexRT[Btn5U];
	}
}
// this is the end of the code
