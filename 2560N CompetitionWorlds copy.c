#pragma config(Sensor, in1,    ArmPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, in3,    lineFollowR,    sensorLineFollower)
#pragma config(Sensor, in4,    lineFollowM,    sensorLineFollower)
#pragma config(Sensor, in5,    lineFollowL,    sensorLineFollower)
#pragma config(Sensor, in6,    lineFollowB,    sensorLineFollower)
#pragma config(Sensor, dgtl1,  BackSwitch,     sensorTouch)
#pragma config(Sensor, dgtl2,  BackSwitch2,    sensorTouch)
#pragma config(Sensor, dgtl6,  sol1,           sensorDigitalOut)
#pragma config(Sensor, dgtl7,  sol2,           sensorDigitalOut)
#pragma config(Sensor, dgtl8,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           RightArm,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BackRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FrontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           MiddleLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RightCollector, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LeftCollector, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           MiddleRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           FrontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BackLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LeftArm,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
port1 = Right Arm
port2 = Left Back
port3 = Big Ball Collector

port4 = power expander A Right Front
port5 = power expander B Right Collector
port6 = power expander C Left Collector
port7 = power expander D Left Front

port8 = Big Ball Collector
port9 = Right Back
port10 = Left Arm
*/

//BASE VARIABLES
signed int moveStick = 0;
signed int turnStick = 0;
signed int rPower = 0;
signed int lPower = 0;

//COLLECTOR VARIABLES
signed int collectorDir = 0;

//ARM VARIABLES
const int armMin = 1388;
const int armMax = 2790;
signed int armDiff = 0;

// AUTONOMOUS VAIABLES
float stage = 0;
int counter1 = 0;
bool runAutonomous = true;
string currentAutonomous = "none";
int Elapsed_Time = 0;
int counterThingy = 0;
const int encoderRev = 360;
int armTarg = armMin;
int k = 2;

int lineFollowState = 0;


#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

void waitForButtonRelease() {
	while (nLCDButtons != 0) {
		wait1Msec(10);
	}
}
void waitForButtonPress() {
	while (nLCDButtons == 0) {
		wait1Msec(10);
	}
}


void pre_auton() {
	allMotorsOff();
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	displayLCDPos(0,1);
	displayNextLCDString("Raven Robotics");
	displayLCDPos(1,6);
	displayNextLCDString("2560");

	wait1Msec(1500);

	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;
	int autonNum = 0;
	string autonCodes[8] = {
		"redMid",
		"redMidS",
		"blueMid",
		"blueMidS",
		"redHang",
		"blueHang",
		"redBlock",
		"blueBlock"
	};
	string autonNames[8] = {
		"Red Mid Zone",
		"Red Mid Zone 1BB",
		"Blue Mid Zone",
		"Blue Mid Zone 1BB",
		"Red Hang Zone",
		"Blue Hang Zone",
		"Red Blocking",
		"Blue Blocking"
	};

	currentAutonomous = autonCodes[0];
	displayLCDCenteredString(0, autonNames[0]);
	displayLCDCenteredString(1, "<   Enter   >");

	while (true) { //loop
		waitForButtonPress();
		if (nLCDButtons == centerButton) {//right button
			break;
		}
		else if (nLCDButtons == rightButton) {//right button
			autonNum++;
			if (autonNum > 7) {
				autonNum = 0;
			}
		}
		else if (nLCDButtons == leftButton) {//left button
			autonNum--;
			if (autonNum < 0) {
				autonNum = 7;
			}
		}
		currentAutonomous = autonCodes[autonNum];
		displayLCDCenteredString(0, autonNames[autonNum]);
		waitForButtonRelease();
	}
	displayLCDCenteredString(1, "Selected");
	wait1Msec(1000);

	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0, "Raven Robotics");
	displayLCDCenteredString(1, "2560");
}

void resetEncoder() {
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;
}


void auton() {
	runAutonomous = true;
	stage = 0;
	Elapsed_Time = 0;
	counterThingy = 0;
  int collSpeed = 0;
	armTarg = armMin;
	int lineValue = 0;
	int rightLine = 0;
	int middleLine = 0;
	int leftLine = 0;
	int backLine = 0;
	int lineWhite = 1500;
	int seeLine = 2400;
	bool armOverride = false;
	signed long encoderValue = 0;
	signed long encoderValue2 = 0;
	byte side = 1; //red side
	int part = 1;

	if (strcmp(currentAutonomous, "redMid") == 0 || strcmp(currentAutonomous, "redMidS") == 0 || strcmp(currentAutonomous, "redHang") == 0 || strcmp(currentAutonomous, "redBlock") == 0) { //if it's the red side
		side = 1;
	}
	else {
		side = 2;
	}


	while (runAutonomous == true) {

		wait1Msec(5);
		++counterThingy;
		if (counterThingy == 2) {
			counterThingy = 0;
			++Elapsed_Time;
		}

		if (counter1 > 0) {
			counter1 = counter1 - 5;
		}
		lineValue = SensorValue(lineFollower);
		rightLine = SensorValue(lineFollowR);
		middleLine = SensorValue(lineFollowM);
		leftLine = SensorValue(lineFollowL);
		backLine = SensorValue(lineFollowB);

		if (side == 1) { //if it's the red side
			encoderValue = SensorValue(leftEncoder);
			encoderValue2 = SensorValue(rightEncoder);
		}
		else { //if its the blue side
			encoderValue2 = SensorValue(leftEncoder);
			encoderValue = SensorValue(rightEncoder);
		}

////////////////////////////////// RED MIDDLE AUTONOMOUS //////////////////////////////////
		if (strcmp(currentAutonomous, "redMid") == 0 || strcmp(currentAutonomous, "blueMid") == 0 || strcmp(currentAutonomous, "redMidS") == 0 || strcmp(currentAutonomous, "blueMidS") == 0) {


			if (part == 1 && (strcmp(currentAutonomous, "redMidS") == 0 || strcmp(currentAutonomous, "blueMidS") == 0)) {
				collSpeed = 127;
				counter1 = 400;
				part++;
			}

			else if (part == 1) {
				if (stage == 0) { //raise arm and unfold
					armTarg = (armMin+armMax)/2;
					collSpeed = 127;
					counter1 = 400;
					stage++;
				}
				else if (stage == 1) { //stop collectorr
					if (counter1 == 0) {
						collSpeed = 0;
						stage++;
					}
				}
				else if (stage == 2) { //go forward to ball
					if (SensorValue(ArmPot) > armTarg-300) {
						resetEncoder();
						lPower = 127;
						rPower = 127;
						stage++;
					}
				}
				else if (stage == 3) { //stop and pause
					if (encoderValue > (encoderRev * 1.3)) {
						lPower = 0;
						rPower = 0;
						counter1 = 300;
						stage++;
					}
				}
				else if (stage == 4) { //reverse to square
					if (counter1 == 0) {
						lPower = -127;
						rPower = -127;
						counter1 = 100;
						stage++;
					}
				}
				else if (stage == 5) { //lower arm
					if (counter1 == 0) {
						armTarg = armMin;
						stage++;
					}
				}
				else if (stage == 6) { //stop and wait for switch
					if (encoderValue < (encoderRev * 0.05)) {
						lPower = 0;
						rPower = 0;
						stage++;
					}
				}
				else if (stage == 7) { //next part
					if (SensorValue(BackSwitch) == 1 || SensorValue(BackSwitch2) == 1) {
						stage = 0;
						part++;
					}
				}
			}
			else if (part == 2) {
				if (stage == 0) { //raise arm
					if (counter1 == 0) {
						resetEncoder();
						collSpeed = 0;
						armOverride = true;
						motor[LeftArm]	= 80; //override arm power
						motor[RightArm]	= 80;
						lPower = 127;
						rPower = 127;
						counter1 = 310;
						//stage++;
						stage = 2;
					}
				}
				else if (stage == 2) { //stop raising arm
					if (counter1 == 0) {
						motor[LeftArm]	= 12; //override arm power
						motor[RightArm]	= 12;
						armTarg = SensorValue(ArmPot);
						counter1 = 500;
						stage++;
					}
				}
				else if (stage == 3) { //slow
					if (side == 1) {
						if (encoderValue > (encoderRev * 1.6)) {
							lPower = 10;
							rPower = 10;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 1.2)) {
							lPower = 10;
							rPower = 10;
							stage++;
						}
					}
				}
				else if (stage == 4) { //stop and pause
					if (side == 1) {
						if (encoderValue > (encoderRev * 1.9)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 1.5)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
				}
				else if (stage == 5) { //turn to balls
					if (counter1 == 0) {
						resetEncoder();
						if (side == 1) {
							lPower = 50;
							rPower = -70;
						}
						else {
							lPower = -70;
							rPower = 50;
						}
						stage++;
					}
				}
				else if (stage == 6) { //slow
					if (side == 1) {
						if (encoderValue > (encoderRev * 0.52)) {
							lPower = 20;
							rPower = -20;
							collSpeed = -127;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 0.6)) {
							lPower = -20;
							rPower = 20;
							collSpeed = -127;
							stage++;
						}
					}
				}
				else if (stage == 7) { //forward slow
					if (side == 1) {
						if (encoderValue > (encoderRev * 0.6)) {
							resetEncoder();
							lPower = 40;
							rPower = 40;
							stage++;
						}

					}
					else {
						if (encoderValue > (encoderRev * 0.57)) {
							resetEncoder();
							lPower = 40;
							rPower = 40;
							stage++;
						}
					}
				}
				else if (stage == 8) { //pause
					if (side == 1) {
						if (encoderValue > (encoderRev * 0.5)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 0.5)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
				}
				else if (stage == 9) { //backup a bit
					if (counter1 == 0) {
						lPower = -30;
						rPower = -30;
						counter1 = 320;
						stage++;
					}
				}
				else if (stage == 10) { //sweep left a bit
					if (counter1 == 0) {
						if (side == 1) {
							lPower = -40;
							rPower = 40;
							counter1 = 120;
						}
						else {
							lPower = 40;
							rPower = -40;
							counter1 = 120;
						}
						stage++;
					}
				}
				else if (stage == 11) { //forward to next ball
					if (counter1 == 0) {
						lPower = 60;
						rPower = 60;
						counter1 = 350;
						stage++;
					}
				}
				else if (stage == 12) { //pause
					if (counter1 == 0) {
						lPower = 0;
						rPower = 0;
						counter1 = 500;
						stage++;
					}
				}
				else if (stage == 13) { //turn
					if (counter1 == 0) {
						resetEncoder();
						if (side == 1) {
							lPower = -90;
							rPower = 90;
						}
						else {
							lPower = 90;
							rPower = -90;
						}
						armOverride = false;
						armTarg = armMin;
						stage++;
					}
				}
				else if (stage == 14) { //slow
					if (encoderValue < (encoderRev * -0.28)) {
						if (side == 1) {
							lPower = -20;
							rPower = 20;
						}
						else {
							lPower = 20;
							rPower = -20;
						}
						stage++;
					}
				}
				else if (stage == 15) { //pause
					if (encoderValue < (encoderRev * -0.32)) {
						lPower = 0;
						rPower = 0;
						counter1 = 100;
						stage = 0;
						part++;
					}
				}
			}
			else if (part == 3){
				if (stage == 0) { //reverse
					if (counter1 == 0) {
						resetEncoder();
						lPower = -90;
						rPower = -90;
						stage++;
					}
				}
				else if (stage == 1) { //slow
					if (encoderValue < (encoderRev * -0.8)) {
						lPower = -20;
						rPower = -20;
						stage++;
					}
				}
				else if (stage == 2) { //forward a wee bit
					if (middleLine < seeLine) {
						resetEncoder();
						lPower = 70;
						rPower = 70;
						stage++;
					}
				}
				else if (stage == 3) { //turn on line
					if (encoderValue > (encoderRev * 0.12)) {
						if (side == 1) {
							lPower = -40;
							rPower = 40;
						}
						else {
							lPower = 40;
							rPower = -40;
						}
						counter1 = 100;
						collSpeed = 0;
						stage++;
					}
				}
				else if (stage == 4) { //delay
					if (counter1 == 0) {
						stage++;
					}
				}
				else if (stage == 5) { //slow
					if (leftLine < seeLine) {
						if (side == 1) {
							lPower = -30;
							rPower = 30;
						}
						else {
							lPower = 30;
							rPower = -30;
						}
						stage++;
					}
				}
				else if (stage == 6) { //delay
					if (middleLine < seeLine) {
						lPower = 50;
						rPower = 50;
						counter1 = 1800;
						stage++;
					}
				}
				else if (stage == 7) { //follow line
					if (side == 1) {
						if (counter1 == 0) { //only follow for a certain time
							if (side == 1) {
								lPower = 127;
								rPower = 80;
							}
							else {
								lPower = 90;
								rPower = 127;
							}
							stage++;
						}

						else {
							if (counter1 > 900) {
								if (leftLine < seeLine) { //go left
									lPower = 10;
									rPower = 40;
									lineFollowState = -1;
								}
								else if (rightLine < seeLine) { //go right
									lPower = 40;
									rPower = 10;
									lineFollowState = 1;
								}
								else if (middleLine < seeLine) { //go straight
									lPower = 60;
									rPower = 50;
									lineFollowState = 0;
								}
							}
							else {
								if (leftLine < seeLine) { //go left
									lPower = 30;
									rPower = 50;
									lineFollowState = -1;
								}
								else if (rightLine < seeLine) { //go right
									lPower = 50;
									rPower = 30;
									lineFollowState = 1;
								}
								else if (middleLine < seeLine) { //go straight
									lPower = 60;
									rPower = 50;
									lineFollowState = 0;
								}
							}
						}
					}
					else {
						if (counter1 == 0) { //only follow for a certain time
							lPower = 90;
							rPower = 127;
							stage++;
						}

						else {
							if (counter1 > 900) {
								if (leftLine < seeLine) { //go left
										lPower = 10;
										rPower = 40;
										lineFollowState = -1;
									}
									else if (rightLine < seeLine) { //go right
										lPower = 40;
										rPower = 10;
										lineFollowState = 1;
									}
									else if (middleLine < seeLine) { //go straight
										lPower = 50;
										rPower = 50;
										lineFollowState = 0;
									}
								}
								else {
								if (leftLine < seeLine) { //go left
									lPower = 20;
									rPower = 40;
									lineFollowState = -1;
								}
								else if (rightLine < seeLine) { //go right
									lPower = 40;
									rPower = 20;
									lineFollowState = 1;
								}
								else if (middleLine < seeLine) { //go straight
									lPower = 60;
									rPower = 60;
									lineFollowState = 0;
								}
							}
						}
					}
				}
				else if (stage == 8) { //slow and raise arm
					if (side == 1) {
						if (encoderValue > (encoderRev * 2.1)) {
							lPower = 20;
							rPower = 20;
							armTarg = armMax;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 2.3)) {
							lPower = 20;
							rPower = 20;
							armTarg = armMax;
							stage++;
						}
					}
				}
				else if (stage == 9) { //forward faster
					if (SensorValue(ArmPot) > armMax-500) {
						lPower = 80;
						rPower = 80;
						stage++;
					}
				}
				else if (stage == 10) { //square with wall
					if (encoderValue > (encoderRev * 3.8)) {
						if (side == 1) {
							lPower = 20;
							rPower = 80;
						}
						else {
							lPower = 80;
							rPower = 20;
						}
						counter1 = 300;
						stage++;
					}
				}
				else if (stage == 11) { //stop and score
					if (counter1 == 0) {
						lPower = 0;
						rPower = 0;
						collSpeed = 127;
						stage++;
						//runAutonomous = false;
					}
				}
			}
		}
////////////////////////////////// HANG ZONE AUTONOMOUS //////////////////////////////////
		else if (strcmp(currentAutonomous, "redHang") == 0 || strcmp(currentAutonomous, "blueHang") == 0) {
			if (part == 1) {
				if (stage == 0) { //unfold
					//collSpeed = 127;
					counter1 = 400;
					stage++;
				}
				if (stage == 1) { //Go forward and intake
					if (counter1 == 0) {
						resetEncoder();
						lPower = 127;
						rPower = 127;
						collSpeed = -127;
						stage++;
					}
				}
				else if (stage == 2) { //wait for running into wall
					if (encoderValue > (encoderRev * 0.85)) {
						counter1 = 50;
						stage++;
					}
				}
				else if (stage == 3) { //stop at small balls
					if (counter1 == 0) {
						lPower = 0;
						rPower = 0;
						counter1 = 900;
						stage++;
					}
				}
				else if (stage == 4) { //reverse back to square
					if (counter1 == 0) {
						resetEncoder();
						armTarg = armMin + 30;
						lPower = -127;
						rPower = -127;
						stage++;
					}
				}
				else if (stage == 5) { //stop, wait for switch
					if (encoderValue < (encoderRev * -1.0)) {
						lPower = 0;
						rPower = 0;
						collSpeed = 0;
						counter1 = 2000;
						stage++;
					}
				}
				else if (stage == 6) { //next part
					if (SensorValue(BackSwitch) == 1) {
						stage = 0;
						part++;
					}
				}
			}
			//2redhang
	////////////////////////////////// PART II of RED HANG ZONE AUTONOMOUS //////////////////////////////////
			else if (part == 2) {
				if (stage == 0) { //move to barrier
					if (counter1 == 0) {
						resetEncoder();
						lPower = 127;
						rPower = 127;
						armTarg = armMin;
						stage++;
					}
				}
				else if (stage == 1) { //pass the red tile
					if (encoderValue > (encoderRev * 3)) {
						lPower = 80;
						rPower = 80;
						stage++;
					}
				}
				else if (stage == 2) { //reset encoder at line
					if (lineValue < lineWhite) {
						lPower = 80;
						rPower = 80;
						resetEncoder();
						stage++;
					}
				}
				else if (stage == 3) { //stop to let ball fall nicely
					if (encoderValue > (encoderRev * 0.0)) {
						resetEncoder();
						lPower = 0;
						rPower = 0;
						counter1 = 600;
						stage++;
					}
				}
				else if (stage == 4) { //forward slow
					if (counter1 == 0) {
						lPower = 60;
						rPower = 60;
						stage++;
					}
				}
				else if (stage == 5) { //stop and pause
					if (encoderValue > (encoderRev * 0.7)) {
						lPower = 0;
						rPower = 0;
						counter1 = 100;
						stage++;
					}
				}
				else if (stage == 6) { //turn
					if (counter1 == 0) {
						resetEncoder();
						if (side == 1) {
							lPower = 80;
							rPower = -25;
						}
						else {
							lPower = -25;
							rPower = 80;
						}
						stage++;
					}
				}
				else if (stage == 7) { //stop and pause
					if (side == 1) {
						if (encoderValue > (encoderRev * 1.15)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
					else {
						if (encoderValue > (encoderRev * 0.8)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
				}
				else if (stage == 8) { //go forwards
					if (counter1 == 0) {
						resetEncoder();
						lPower = 127;
						rPower = 127;
						stage++;
					}
				}
				else if (stage == 9) { //slow down
					if (encoderValue > (encoderRev * 0.45)) {
						lPower = 30;
						rPower = 30;
						stage++;
					}
				}
				else if (stage == 10) { //reset encoder
					if (lineValue < lineWhite) { //we see white line
						resetEncoder();
						stage++;
					}
				}
				else if (stage == 11) { //stop and raise arm
					if (encoderValue > (encoderRev * 0.05)) {
						lPower = 0;
						rPower = 0;
						armTarg = armMax;
						stage++;
					}
				}
				else if (stage == 12) { //turn to face goal
					if (SensorValue(ArmPot) > armMax - 700) {
						resetEncoder();
						if (side == 1) {
							lPower = -55;
							rPower = 55;
						}
						else {
							lPower = 55;
							rPower = -55;
						}
						stage++;
					}
				}
				else if (stage == 13) { //go forwards to goal
					//if (backLine < seeLine) { //we see white line
					if (encoderValue2 > (encoderRev * 0.4)) { //0.35
						lPower = 80;
						rPower = 80;
						counter1 = 500;
						part++;
						stage = 0;
					}
				}
			}
			////////////////////////////////// PART III OF RED HANG ZONE AUTONOMOUS //////////////////////////////////
			else if (part == 3) {
				if (stage == 0) { //score
					if (counter1 == 0) {
						lPower = 0;
						rPower = 0;
						collSpeed = 127;
						counter1 = 1800;
						stage++;
					}
				}
				else if (stage == 1) { //backup a bit
					if (counter1 == 0) {
						resetEncoder();
						if (side == 1) {
							lPower = -60;
							lPower = -60;
							//rPower = -44;
						}
						else {
							//lPower = -65;
							//rPower = -50;
							lPower = -60;
							lPower = -60;
						}
						collSpeed = 0;
						stage++;
					}
				}
				else if (stage == 2) { //wait a bit
					if (side == 1) {
						if (encoderValue < (encoderRev * -0.76)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
					else {
						if (encoderValue < (encoderRev * -0.6)) {
							lPower = 0;
							rPower = 0;
							counter1 = 100;
							stage++;
						}
					}
				}
				else if (stage == 3) { //lower arm to score big ball
					if (counter1 == 0) {
						armTarg = armMin + (armMax - armMin) * 0.68;
						counter1 = 700;
						stage++;
					}
				}
				else if (stage == 4) { //score big ball
					if (counter1 == 0) {
						collSpeed = -127;
						counter1 = 1000;
						stage++;
					}
				}
				else if (stage == 5) { //raise arm and push
					if (counter1 == 0) {
						armTarg = armTarg + 200;
						rPower = 80;
						lPower = 80;
						collSpeed = 0;
						counter1 = 130;
						stage++;
					}
				}
				else if (stage == 6) { //end
					if (counter1 == 0) {
						rPower = 0;
						lPower = 0;
						stage++;
						runAutonomous = false;
					}
				}
			}
		}
////////////////////////////////// BLOCKING AUTONOMOUS //////////////////////////////////
		else if (strcmp(currentAutonomous, "redBlock") == 0 || strcmp(currentAutonomous, "blueBlock") == 0) {
			if (stage == 0) { //unfold
				collSpeed = 127;
				counter1 = 200;
				stage++;
			}
			if (stage == 1) { //move to barrier
				if (counter1 == 0) {
					resetEncoder();
					collSpeed = 0;
					lPower = 127;
					rPower = 127;
					armTarg = armMin;
					stage++;
				}
			}
			else if (stage == 2) { //stop to let ball fall nicely
				if (encoderValue > (encoderRev * 2.5)) {
					lPower = 0;
					rPower = 0;
					counter1 = 400;
					stage++;
				}
			}
			else if (stage == 3) { //forward slow
				if (counter1 == 0) {
					lPower = 60;
					rPower = 60;
					stage++;
				}
			}
			else if (stage == 4) { //stop and pause
				if (encoderValue > (encoderRev * 3.9)) {
					lPower = 0;
					rPower = 0;
					counter1 = 100;
					stage++;
				}
			}
			else if (stage == 5) { //turn
				if (counter1 == 0) {
					resetEncoder();
					if (side == 1) {
						lPower = -80;
						rPower = 55;
					}
					else {
						lPower = 55;
						rPower = -80;
					}
					stage++;
				}
			}
			else if (stage == 6) { //stop and pause
				if (side == 1) {
					if (encoderValue < (encoderRev * -1.03)) {
						lPower = 0;
						rPower = 0;
						counter1 = 100;
						stage++;
					}
				}
				else {
					if (encoderValue < (encoderRev * -0.9)) {
						lPower = 0;
						rPower = 0;
						counter1 = 100;
						stage++;
					}
				}
			}
			else if (stage == 7) { //reverse to block
				if (counter1 == 0) {
					resetEncoder();
					lPower = -127;
					rPower = -127;
					counter1 = 3000;
					collSpeed = -127;
					stage++;
				}
			}
			else if (stage == 8) { //spit out bucky
				if (encoderValue < (encoderRev * -3) || counter1 <= 1800) {
					collSpeed = 127;
					stage++;
				}
			}
			else if (stage == 9) { //stop
				if (encoderValue < (encoderRev * -7) || counter1 == 0) {
					lPower = 0;
					rPower = 0;
					collSpeed = 0;
					stage++;
					runAutonomous = false;
				}
			}
		}
		motor[FrontLeft]	= lPower;
		motor[MiddleLeft]	= lPower;
		motor[BackLeft]		= lPower;
		motor[FrontRight]	= rPower;
		motor[MiddleRight]= rPower;
		motor[BackRight]	= rPower;
		motor[LeftCollector] = -collSpeed;
		motor[RightCollector] = -collSpeed;

		//---------------------------------------------
		// Shoulder Control
		//---------------------------------------------
    if (runAutonomous == false) { //ended auton
      motor[RightArm]	= 15;
      motor[LeftArm]	= 15;
    }
    else {
    	if (armOverride == false) {
	    	if (SensorValue(ArmPot) > armMin-600) { //if its a valid reading
		      armDiff = armTarg - SensorValue(ArmPot); //find difference

		      if (armDiff < 0) { k = 20; } //go slower on the way down
		      else { k = 3; } //full speed on the way down

		      if (armTarg == armMin && SensorValue(ArmPot) < armMin + 300) { //if we're sitting at the bottom
			      motor[RightArm]	= 0;
			      motor[LeftArm]	= 0;
					}
					else {
			      motor[RightArm]	= armDiff/k + 15;
			      motor[LeftArm]	= armDiff/k + 15;
		      }
		    }
		    else {
		      motor[RightArm]	= 10;
		      motor[LeftArm]	= 10;
		    }
	    } //end armOverride
    } //end armPID

	} //			END OF SKILLS AUTONOMOUS
}
task autonomous() {
	auton();
}

task usercontrol() {
	// User control code here, inside the loop
	//motor[RightCollector] = 127;
	//wait1Msec(250);
	//motor[LeftCollector] = 127;
	//wait1Msec(250);
	//motor[RightCollector] = 0;
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;

	while (true) {

    if (vexRT[Btn8U] == 1 && vexRT[Btn7U] == 1 && vexRT[Btn8R] == 1 && vexRT[Btn7L] == 1) {
    	pre_auton();
    }
    //else if (vexRT[Btn7U] == 1) {
    //	auton();
    //}

		//////////BASE CONTROL//////////
    int powerL = 1.65*(vexRT[Ch3]-50);
    int powerR = 1.65*(vexRT[Ch3]+50);

    if (abs(vexRT[Ch3]) > 50){
    	motor[FrontLeft]	= powerL;
			motor[MiddleLeft]	= powerL;
			motor[BackLeft]		= powerL;
			motor[FrontRight]	= powerR;
			motor[MiddleRight]= powerR;
			motor[BackRight]	= powerR;
  	}
  	else {
  		motor[FrontLeft]	= 0;
			motor[MiddleLeft]	= 0;
			motor[BackLeft]		= 0;
			motor[FrontRight]	= 0;
			motor[MiddleRight]= 0;
			motor[BackRight]	= 0;
  	}

    if ((vexRT[Ch4]) > 50) {
   		motor[FrontLeft]	= vexRT[Ch4];
   		motor[MiddleLeft]	= vexRT[Ch4];
   		motor[BackLeft]		= vexRT[Ch4];

   		motor[FrontRight]	= vexRT[Ch4] * -1;
   		motor[MiddleRight]= vexRT[Ch4] * -1;
   		motor[BackRight]	= vexRT[Ch4] * -1;
  }
  	if ((vexRT[Ch4]) < -50) {
  		motor[FrontLeft]	= vexRT[Ch4];
   		motor[MiddleLeft]	= vexRT[Ch4];
   		motor[BackLeft]		= vexRT[Ch4];

   		motor[FrontRight]	= vexRT[Ch4] * -1;
   		motor[MiddleRight]= vexRT[Ch4] * -1;
   		motor[BackRight]	= vexRT[Ch4] * -1;

  }



  //  if (abs(vexRT[Ch3]) > 30) {
  // 	 moveStick = vexRT[Ch3];
  //  }
  //  else {
  //  	moveStick = 0;
  //  }
  //  if (abs(vexRT[Ch4]) > 30) {
  // 	 turnStick = vexRT[Ch4];
  //  }
  //  else {
  //  	turnStick = 0;
  //  }

		//rPower = moveStick - turnStick;
		//lPower = moveStick + turnStick;

		////forward					= 127,	127
		////backwards				= -127,	-127
		////left 						= -127,	127
		////right						= 127,	-127
		////forwards right	= 254,	0
		////forwards left		= 0,		254
		////backwards right	= 0,		-254
		////backwards left	= -254,	0

		//if (rPower > 127) {
		//	rPower = 127;
		//} else if (rPower < -127) {
		//	rPower = -127;
		//} else if (lPower > 127) {
		//	lPower = 127;
		//} else if (lPower < -127) {
		//	lPower = -127;
		//}

		//if (vexRT[Btn8D] == 1) {

		//}
		//else {
		//	motor[FrontLeft]	= lPower;
		//	motor[MiddleLeft]	= lPower;
		//	motor[BackLeft]		= lPower;
		//	motor[FrontRight]	= rPower;
		//	motor[MiddleRight]= rPower;
		//	motor[BackRight]	= rPower;
		//}

		//////////SHOULDER CONTROL///////
		if (vexRT[Ch2] > 50 && SensorValue(ArmPot) < armMax-50) {
			motor[RightArm] = vexRT[Ch2];
			motor[LeftArm] = vexRT[Ch2];

		} else if (vexRT[Ch2] < -50 && SensorValue(ArmPot) > armMin) {
			motor[RightArm] = vexRT[Ch2]/2;
			motor[LeftArm] = vexRT[Ch2]/2;

		} else if (SensorValue(ArmPot) < armMin) {
			motor[RightArm] = 0;
			motor[LeftArm] = 0;

		} else {
			motor[RightArm] = 20;
			motor[LeftArm] = 20;
		}

		//////////COLLECTOR CONTROL//////////
		if (vexRT[Btn6U] == 1) {
			collectorDir = 1;
		}
		else if (vexRT[Btn6D] == 1) {
			collectorDir = -1;
		}
		else {
			collectorDir = 0.2;
		}
		motor[RightCollector]	= 127*collectorDir;
		motor[LeftCollector]	= 127*collectorDir;
	}
}
